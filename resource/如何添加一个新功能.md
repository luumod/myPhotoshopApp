## 如何添加一个新功能

示例：（滑动条）对比度线性展宽

`Showeffect`文件

1. 定义枚举变量

```cpp
SHOW::LINEAR,

//-------------
case T::LINEAR:
	return true;

//-------------
case SHOW::LINEAR:
	return 10;
```

2. 添加一个ToolButton

```cpp
QWidget* f3 = createToolBtnItemWidget(tr("对比度展宽"), SHOW::LINEAR);
f3->setStatusTip(tr("对比度展宽"));
gird_effect->addWidget(f3, 1, 0);
```

3. 定义可滑动调整的参数：

```cpp
double linear_g1 = 0.0, linear_g2 = 0.0;//假定目标区域定义槽函数
```

4. 定义响应槽函数

```cpp
void Showeffect::onTriggered_slider_valueChange_linearg1(double g1)
{
	this->linear_g1 = g1;
	if (!linear_mode) {
		showContrastLinearBroaden();
	}
	else {
		showBGRContrastLinearBroaden();
	}
}

void Showeffect::onTriggered_slider_valueChange_linearg2(double g2)
{
	this->linear_g2 = g2;
	if (!linear_mode) {
		showContrastLinearBroaden();
	}
	else {
		showBGRContrastLinearBroaden();
	}
}
```

5. 定义具体函数的实现：
   1. 首先获取getMat;
   2. 操作
   3. 最后更新Object::update

```cpp
cv::Mat Showeffect::showContrastLinearBroaden(cv::Mat mat)
{
	//对比度线性展宽 (f1,f2) --> (g1,g2)
	cv::Mat grayMat;

	cv::Mat _mt;
	getMat(_mt);
	if (mat.empty()) {
		//转换为灰度图
		cv::cvtColor(_mt, grayMat, cv::COLOR_BGR2GRAY);
	}
	else {
		grayMat = mat;
	}

	double f1, f2;
	cv::minMaxLoc(grayMat, &f1, &f2);
	double g1 = this->linear_g1;
	double g2 = this->linear_g2;


	double k1 = g1 / f1;
	double k2 = (g2 - g1) / (f2 - f1);
	double k3 = (255 - g2) / (255 - f2);

	for (int i = 0; i < grayMat.rows; i++) {
		for (int j = 0; j < grayMat.cols; j++) {
			uchar pix = grayMat.at<uchar>(i, j);
			if (pix >= 0 && pix < f1) {
				grayMat.at<uchar>(i, j) = cv::saturate_cast<uchar>(k1 * pix);
			}
			else if (pix >= f1 && pix <= f2) {
				grayMat.at<uchar>(i, j) = cv::saturate_cast<uchar>(k2 * (pix - f1) + g1);
			}
			else if (pix > f2 && pix <= 255) {
				grayMat.at<uchar>(i, j) = cv::saturate_cast<uchar>(k3 * (pix - f2) + g2);
			}
		}
	}
	if (!linear_mode){ // !=0 彩色无须更新
		Object::update(grayMat);
	}
	return grayMat;
}

void Showeffect::showBGRContrastLinearBroaden()
{
	std::vector<cv::Mat> channels;
	cv::Mat _mt;
	getMat(_mt);
	cv::split(_mt, channels);
	cv::Mat ch1 = showContrastLinearBroaden(channels[0]);
	cv::Mat ch2 = showContrastLinearBroaden(channels[1]);
	cv::Mat ch3 = showContrastLinearBroaden(channels[2]);
	cv::Mat res;
	cv::merge(channels, res);

	Object::update(res);//彩色图
}
```

6. 创建调整GUI

```cpp
QWidget* Widget::create_GUIContrast()
{
	ls_slider_linear.resize(2);
	std::function<void(int)> funcLinearG1 = [=](int value) {
		//将int映射为double
		showeffect->onTriggered_slider_valueChange_linearg1(value);
	};
	std::function<void(int)> funcLinearG2 = [=](int value) {
		//将int映射为double
		showeffect->onTriggered_slider_valueChange_linearg2(value);
	};

	auto w = new QWidget;
	w->setLayout(createDialog_nSlider_GUItemplate<int, Blur*>(
		ls_slider_linear,
		QList<int>() << 0 << 255,
		QList<int>() << 0 << 255,
		QList<int>() << 1 << 1,
		QList<QString>() << "linearG1_slider" << "linearG2_slider",
		QList<QString>() << "灰度上限" <<"灰度下限",
		QList< std::function<void(int)>>() << funcLinearG1 << funcLinearG2,
		true)
	);
	// 获取QWidget的布局
	QVBoxLayout* layout = dynamic_cast<QVBoxLayout*>(w->layout());

	if (layout) {
		QHBoxLayout* hlayout = new QHBoxLayout;
		QRadioButton* r_btn1 = new QRadioButton("灰度图");
		r_btn1->setChecked(true);
		QRadioButton* r_btn2 = new QRadioButton("彩色图");
		connect(r_btn1, &QRadioButton::toggled, this, [=](bool checked) {
			showeffect->linear_mode = !checked;
			});
		connect(r_btn2, &QRadioButton::toggled, this, [=](bool checked) {
			showeffect->linear_mode = checked;
			});
		hlayout->addWidget(r_btn1,0,Qt::AlignHCenter);
		hlayout->addWidget(r_btn2,0, Qt::AlignHCenter);

		layout->insertLayout(0, hlayout);
	}

	return w;
}
```

7. 添加此GUI创建方式：

```cpp
case 10:
		return create_GUIContrast();
```

8. 在布局中添加此GUI

```cpp
for (int i = 0; i < 11; i++) {
    AdjArea_StackedWidgets->insertWidget(i, choice_GUI_create(i));
}
```

## 不带滑动条

示例：（固定值）实现灰度图的分段线性对比度展宽

1. 在BaseOperate函数中，添加函数的定义与实现：

```CPP
void BaseOperate::contrastLinearBroaden()
{
	//对比度线性展宽 (f1,f2) --> (g1,g2)
	cv::Mat grayMat;
	//转换为灰度图
	cv::cvtColor(get()->res->curr_mt, grayMat, cv::COLOR_BGR2GRAY);

	double f1, f2;
	cv::minMaxLoc(grayMat, &f1, &f2);
	double g1 = 0.0, g2 = 255.0;

	double k1 = g1 / f1;
	double k2 = (g2 - g1) / (f2 - f1);
	double k3 = (255 - g2) / (255 - f2);

	for (int i = 0; i < grayMat.rows; i++) {
		for (int j = 0; j < grayMat.cols; j++) {
			uchar pix = grayMat.at<uchar>(i, j);
			if (pix >= 0 && pix < f1) {
				grayMat.at<uchar>(i, j) = cv::saturate_cast<uchar>(k1 * pix);
			}
			else if (pix >= f1 && pix <= f2) {
				grayMat.at<uchar>(i, j) = cv::saturate_cast<uchar>(k2 * (pix - f1) + g1);
			}
			else if (pix > f2 && pix <= 255) {
				grayMat.at<uchar>(i, j) = cv::saturate_cast<uchar>(k3 * (pix - f2) + g2);
			}
		}
	}
	show_wid->lab_img->setPixmap(QPixmap::fromImage(Mat2QImage(grayMat)));
	show_wid->show();
}
```

2. Widget.cpp中添加行为的定义与响应

```cpp
QMenu* menu_contrastLinear = new QMenu("对比度线性展宽", this);
menu_contrastLinear->addAction("灰度图", this, [=]() {img_base->showContrastLinearBroaden(); });
menu_contrastLinear->addAction("彩色图", this, [=]() {img_base->showBGRContrastLinearBroaden(); });
menu_func->addMenu(menu_contrastLinear);
menu_func->addSeparator();
menu_func->addAction(action_fileInfo); //图片属性信息
```



